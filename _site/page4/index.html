<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Dhruv's Blog &middot; Always Be Learnin'
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Dhruv's Blog" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">Dhruv's Blog</a>
          <small>Always Be Learnin'</small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/about">About</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/archive">Archive</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/atom.xml">Feed</a></small>
          
        </h3>
      </header>

      <main>
        <div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/2015/02/23/mailchimip-clojure/">
        Building a login form in Clojurescript and Reagent
      </a>
    </h1>

    <time datetime="2015-02-23T00:00:00-08:00" class="post-date">23 Feb 2015</time>

    <p>I recently have been reading up on LISP (on LISP) a lot lately and have been quite excited by the ideas and simplicity of the language. So I looked for a nice project to get started on and decided to try building a simple Mailchimp-esque login form in Clojurescript to get my feet wet. You can see the dead simple demo <a href="https://dhruvp.github.io/mailchimp-form-cljs/" target="_blank">here</a>, and the full repo <a href="https://github.com/dhruvp/mailchimp-form-cljs" target="_blank">here</a>. It is inspired by Lukas Ruebbelke’s awesome <a href="http://onehungrymind.com/build-mailchimp-signup-form-angularjs/" target="_blank">post</a> on the same idea, but in Angular. Below, I’m going to walk you through the process of how to get from 0 to a working site and all the cool things I learned along the way. Ready? LEGGO!</p>

<h2 id="what-is-clojurescript">What is Clojurescript</h2>

<p>Clojurescript is tightly associated with Clojure, the LISP with all the attention these days that runs on the JVM. The language itself is almost identical to Clojure with the primary difference being that Clojurescript compiles to Javascript and thus can be used for client side code! If you want to learn more about Clojure and Clojurescript, do listen to Rich Hickey’s talks on the language and its ideas. They’re really well presented and beautifully explained. See the following:</p>

<ul>
  <li><a href="https://www.infoq.com/author/Rich-Hickey" target="_blank">A collection of Rich Hickey Talks</a></li>
  <li><a href="https://www.braveclojure.com/" target="_blank">An introduction to learning Clojure</a></li>
  <li><a href="https://github.com/magomimmo/modern-cljs">A series of tutorials on Clojurescript</a></li>
</ul>

<h2 id="what-are-we-going-to-do">What are we going to do?</h2>

<ol>
  <li>Setup a development process for Clojurescript</li>
  <li>Walk through building a simple form for login with the following:
    <ul>
      <li>Validate the form as it’s being typed</li>
      <li>Hide and show labels based on your focus</li>
    </ul>
  </li>
</ol>

<p>Alright then! On to step 1.</p>

<h2 id="setting-up-your-developer-workflow">Setting up your developer workflow</h2>

<p>First, let’s get a developer flow going so that the build process gets out of the way and we can focus on coding. Do the following:</p>

<ol>
  <li>Install <a href="https://github.com/technomancy/leiningen" target="_blank">Leiningen</a>
    <ul>
      <li>Leiningen is a tool for automating Clojure project tasks.</li>
    </ul>
  </li>
  <li>Go to the directory you wish to create your project in and type the following:
    <ul>
      <li></li>
    </ul>
  </li>
</ol>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">    lein new reagent myproject
    </code></pre></figure>

<ol>
  <li>cd into your new project and execute the following:
    <ul>
      <li></li>
    </ul>
  </li>
</ol>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">    lein ring server
    </code></pre></figure>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* You should see Leiningen try and download a whole host of dependencies. Not to worry!
* At the end, you should see a server running on localhost:3000
</code></pre></div></div>

<ol>
  <li>Open a new terminal and execute the following from the base of your project:
    <ul>
      <li></li>
    </ul>
  </li>
</ol>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">    lein figwheel
    </code></pre></figure>

<h2 id="what-was-all-that">What was all that?</h2>

<p>Here’s what each of those pieces were:</p>

<h3 id="leiningen"><a href="https://github.com/technomancy/leiningen" target="_blank">Leiningen</a></h3>
<p>This is an absolute necessity for clojure development. It helps automate tasks and even comes with a repl!</p>

<h3 id="ring"><a href="https://github.com/weavejester/lein-ring" target="_blank">Ring</a></h3>
<p>Ring is a simple abstraction for HTTP in Clojure. It allows you to create a webserver, define middleware etc.</p>

<h3 id="figwheel"><a href="https://github.com/bhauman/lein-figwheel" target="_blank">Figwheel</a></h3>
<p>Figwheel autoreloads and compiles your clojurescript code so that you can live code and see your changes update in the browser. It also comes with a repl for your clojurescript so you can evaluate your code there. This will come in handy.</p>

<h3 id="reagent"><a href="https://github.com/reagent-project/reagent" target="_blank">Reagent</a></h3>
<p>Reagent wraps the React.js library and provides a neat Clojurescript interface to it. This is my first time using it and it’s been very simple to pick up and use.</p>

<h2 id="understanding-the-basic-setup">Understanding the basic setup</h2>

<p>Let’s get started then. We’re going to first look at some of the scaffolding code and understand at a high level what’s going on. The code is in this <a href="https://github.com/dhruvp/mailchimp-form-cljs" target="_blank">repo</a> for following along.</p>

<p>Open up the core.cljs file in <code class="highlighter-rouge">src/cljs/&lt;your-project&gt;/core.cljs</code> in emacs or your favorite editor.</p>

<p>You should see a few function definitions under the heading “Views”. This is the first thing we’re going to edit. Each of these functions return separate DOM elements. If you check out the code under the Routes heading, you should see the following:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">secretary/defroute</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">session/put!</span><span class="w"> </span><span class="no">:current-page</span><span class="w"> </span><span class="o">#</span><span class="ss">'home-page</span><span class="p">))</span></code></pre></figure>

<p>What’s happening there is <a href="https://github.com/gf3/secretary" target="_blank">Secretary</a>, another Clojurescript library we are using for routing, is matching the route “/” to the home-page function we defined in the views section. The function is simply setting a session variable, :current-page, to be home-page upon the match.</p>

<p>Then, at the bottom of the page, we see are telling reagent to render what’s defined by current-page, and bind it to whatever is at document.getElementById(“app”). That’s defined here:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="c1">;; Initialize app</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">init!</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">hook-browser-navigation!</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">reagent/render-component</span><span class="w"> </span><span class="p">[</span><span class="n">current-page</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">.getElementById</span><span class="w"> </span><span class="n">js/document</span><span class="w"> </span><span class="s">"app"</span><span class="p">)))</span></code></pre></figure>

<p>Ok cool. So we are just going to play around with the home page to get what we need. Let’s take a closer look at how the home-page view is being defined quickly.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to my-project"</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:href</span><span class="w"> </span><span class="s">"#/about"</span><span class="p">}</span><span class="w"> </span><span class="s">"go to about page"</span><span class="p">]]])</span><span class="w">
 </span></code></pre></figure>

<p>home-page is just a function that returns DOM elements (theme alert - we are going to make many such functions!). The syntax for defining HTML is similar to <a href="https://github.com/weavejester/hiccup">hiccup</a> in that HTML is represented by clojure vectors. The first element of the vector is the tag of the element (in this case :div as in [:div …]). We can then place other vectors(that represent elements) inside the original vector to represent element nesting (in the example above, the Welcome to my Project h2 is nested inside the div). So to show an example, I’ve pasted a vector representation of a DOM and its corresponding HTML element below it.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to my-project"</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:href</span><span class="w"> </span><span class="s">"#/about"</span><span class="p">}</span><span class="w"> </span><span class="s">"go to about page"</span><span class="p">]]]</span></code></pre></figure>

<p>And the HTML:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;h2&gt;</span>Welcome to my-project<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#/about"</span> <span class="na">go</span> <span class="na">to</span> <span class="na">about</span> <span class="na">page</span><span class="nt">&gt;&lt;/a&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<p>This is cool because we can now pass along representations of DOM elements as first class data structures! I can pass them to functions, return them, map over them, compose them … Basically the possibilities are endless.</p>

<h2 id="starting-to-build-the-form">Starting to build the form</h2>

<p>Ok now let’s remove the gunk and focus just on the home page. We don’t really need the about page. Edit the home-page code to be</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
    </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
    </span><span class="p">[</span><span class="no">:form</span><span class="p">]])</span><span class="w">
 </span></code></pre></figure>

<p>We now have an empty form! Look at that.</p>

<p>Let’s now create a function for rendering an email-input component. We define a simple email-input function that for now will return an empty-div. We’ll fix it shortly.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">email-input</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="p">])</span></code></pre></figure>

<h2 id="data-binding">Data Binding</h2>

<p>Ok back to the form. We’re going to need a variable to track the state of the email-address field and auto updates as users type in their email address. In Angular and similar frameworks, we would achieve this by using some form of two way data binding. In reagent, we do something very similar using an Atom. Atoms are one of the few mutable data structure in Clojure. Reagent extends a Clojure Atom by ensuring that whenever an Atom is mutated, any component that uses it is rerendered (so we don’t have to worry about updating our views). So let’s use that!</p>

<p>Let’s just create a new atom for email-address to start.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="c1">;; We define the email-address as an atom right here</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">email-address</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
       </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="no">:form</span><span class="p">]])))</span></code></pre></figure>

<p>Notice how we changed home-page now to return a function. Reagent requires that if we do any setup via lets etc., we return a function that in turn returns the elements we want. This just sets up the lexical scoping up front.</p>

<h2 id="the-building-blocks-of-our-ui---functions">The Building Blocks of our UI - Functions</h2>

<p>Let’s now create the HTML for our actual email input form. We’re going to do this by creating a function that is just responsible for the UI of the email input. What’s awesome about this is that functions are now the building blocks of our UI. That’s exactly how LISP was intended to be used!</p>

<p>Let’s develop a generic function for input-elements, and have the email-input just be a specific application of that function.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">input-element</span><span class="w">
  </span><span class="s">"An input element which updates its value on change"</span><span class="w">
  </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:input</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">id</span><span class="w">
           </span><span class="no">:name</span><span class="w"> </span><span class="nb">name</span><span class="w">
           </span><span class="no">:class</span><span class="w"> </span><span class="s">"form-control"</span><span class="w">
           </span><span class="no">:type</span><span class="w"> </span><span class="n">type</span><span class="w">
           </span><span class="no">:required</span><span class="w"> </span><span class="s">""</span><span class="w">
           </span><span class="no">:value</span><span class="w"> </span><span class="o">@</span><span class="n">value</span><span class="w">
           </span><span class="no">:on-change</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">.-target</span><span class="w"> </span><span class="n">.-value</span><span class="p">))}])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">email-input</span><span class="w">
  </span><span class="p">[</span><span class="n">email-address-atom</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">input-element</span><span class="w"> </span><span class="s">"email"</span><span class="w"> </span><span class="s">"email"</span><span class="w"> </span><span class="s">"email"</span><span class="w"> </span><span class="n">email-address-atom</span><span class="p">))</span></code></pre></figure>

<p>Let’s now use this UI component and put it into our original form.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="c1">;; We define the email-address as an atom right here</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">email-address</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
       </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="no">:form</span><span class="w">
       </span><span class="c1">;; We use the email-input component here</span><span class="w">
        </span><span class="p">[</span><span class="n">email-input</span><span class="w"> </span><span class="n">email-address</span><span class="p">]]])))</span></code></pre></figure>

<p>Notice how we compose the email-input component into a form div by just placing a vector [email-input email-address] inside the vector describing the form. Super simple! The first element of the vector is just the name of the function defining the component and the next elements are the arguments to that function. You can see how easy it is to build and compose components to make simple, modular ui elements.</p>

<h2 id="implementing-two-way-data-binding">Implementing Two Way Data Binding</h2>

<p>Now, we need to implement a basic form of two way data binding so that when the user types something in we are able to track it. We can implement this with an :on-change attribute on our element. We pass the following function into :on-change attribute of the input element.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="o">#</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">.-target</span><span class="w"> </span><span class="n">.-value</span><span class="p">))</span></code></pre></figure>

<p>Here, we are resetting the value of atom to be the output of (-&gt; % .-target .-value). The hell is that? That is a <a href="http://clojuredocs.org/clojure.core/-%3E">macro</a> that expands to (.-value (.-target %)) or just event.target.value in JavaScript. Note that .-value and .-target are how we call JavaScript properties in Clojurescript (yes! Clojurescript let’s you talk to JavaScript objects!). The cool thing here is we just have to change the atom here and ANY other component that uses this atom rerenders automatically! This is some sweet stuff already.</p>

<p>And what’s with the “@value” we passed to the value field of input? Well the @ is just telling the function to apply the value of the atom (So that we don’t pass in an atom which HTML has no idea how to display!).</p>

<p>So now if you check out localhost:3000, you should see a simple page with an input for your email-address! Add in the following to display the email address.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">email-address</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
       </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="no">:form</span><span class="w">
        </span><span class="p">[</span><span class="n">email-input</span><span class="w"> </span><span class="n">email-address</span><span class="p">]]</span><span class="w">
       </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="s">"EMAIL ADDRESS IS "</span><span class="w"> </span><span class="o">@</span><span class="n">email-address</span><span class="p">]])))</span></code></pre></figure>

<h2 id="sharing-state-between-components">Sharing state between components</h2>

<p>Ok, now I want to display a little message that says “What is your email address?” when you click on the email box. Let’s create a component for that.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="c1">;;generic function</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">prompt-message</span><span class="w">
  </span><span class="s">"A prompt that will animate to help the user with a given input"</span><span class="w">
  </span><span class="p">[</span><span class="n">message</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"my-messages"</span><span class="p">}</span><span class="w">
   </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"prompt message-animation"</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="no">:p</span><span class="w"> </span><span class="n">message</span><span class="p">]]])</span><span class="w">

</span><span class="c1">;;specific function</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">email-prompt</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">prompt-message</span><span class="w"> </span><span class="s">"What's your email address?"</span><span class="p">))</span></code></pre></figure>

<p>Depending on when that input is in focus, we need to hide or show the component we defined above. The below function is going to do just that. It will take in information about the input, and a prompt element, and return a representation of a DOM element that has an input field, and a prompt field that appears above it if the input is in focus.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">input-and-prompt</span><span class="w">
  </span><span class="s">"Creates an input box and a prompt box that appears above the input when the input comes into focus."</span><span class="w">
  </span><span class="p">[</span><span class="n">label-value</span><span class="w"> </span><span class="n">input-name</span><span class="w"> </span><span class="n">input-type</span><span class="w"> </span><span class="n">input-element-arg</span><span class="w"> </span><span class="n">prompt-element</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">input-focus</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">false</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w">
       </span><span class="p">[</span><span class="no">:label</span><span class="w"> </span><span class="n">label-value</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="o">@</span><span class="n">input-focus</span><span class="w"> </span><span class="n">prompt-element</span><span class="w"> </span><span class="p">[</span><span class="no">:div</span><span class="p">])</span><span class="w">
       </span><span class="p">[</span><span class="n">input-element</span><span class="w"> </span><span class="n">input-name</span><span class="w"> </span><span class="n">input-name</span><span class="w"> </span><span class="n">input-type</span><span class="w"> </span><span class="n">input-element-arg</span><span class="w"> </span><span class="n">input-focus</span><span class="p">]])))</span></code></pre></figure>

<p>Let’s dive in a little deeper. The below snippet is what hides and shows the prompt element:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="o">@</span><span class="n">input-focus</span><span class="w"> </span><span class="n">prompt-element</span><span class="w"> </span><span class="p">[</span><span class="no">:div</span><span class="p">])</span></code></pre></figure>

<p>If the input-focus atom is set to true, we return the prompt-element, otherwise, we return an empty div. COOL! We need to pass this input-focus atom to our input-element and have it update this atom on focus or blur. Let’s share this state variable by making input-element use it.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">input-element</span><span class="w">
  </span><span class="s">"An input element which updates its value and on focus parameters on change, blur, and focus"</span><span class="w">
  </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">in-focus</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:input</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">id</span><span class="w">
           </span><span class="no">:name</span><span class="w"> </span><span class="nb">name</span><span class="w">
           </span><span class="no">:class</span><span class="w"> </span><span class="s">"form-control"</span><span class="w">
           </span><span class="no">:type</span><span class="w"> </span><span class="n">type</span><span class="w">
           </span><span class="no">:required</span><span class="w"> </span><span class="s">""</span><span class="w">
           </span><span class="no">:value</span><span class="w"> </span><span class="o">@</span><span class="n">value</span><span class="w">
           </span><span class="no">:on-change</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">.-target</span><span class="w"> </span><span class="n">.-value</span><span class="p">))</span><span class="w">
           </span><span class="c1">;; Below we change the state of in-focus</span><span class="w">
           </span><span class="no">:on-focus</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">in-focus</span><span class="w"> </span><span class="nb">not</span><span class="p">)</span><span class="w">
           </span><span class="no">:on-blur</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">in-focus</span><span class="w"> </span><span class="nb">not</span><span class="p">)}])</span></code></pre></figure>

<p>So now we have our input element swap the in-focus atom to be its converse when an on-focus or on-blur event happens. Dope.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>Let’s now use all these functions we’ve built.</p>

<p>Rename the email-input method to be email-form, and change it to be what you see below so that it uses input-and-prompt.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">email-form</span><span class="w">
  </span><span class="p">[</span><span class="n">email-address-atom</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">input-and-prompt</span><span class="w"> </span><span class="s">"email"</span><span class="w">
                    </span><span class="s">"email"</span><span class="w">
                    </span><span class="s">"email"</span><span class="w">
                    </span><span class="n">email-address-atom</span><span class="w">
                    </span><span class="p">[</span><span class="n">prompt-message</span><span class="w"> </span><span class="s">"What's your email?"</span><span class="p">]))</span></code></pre></figure>

<p>Right now, your home-page function should be:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">email-address</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
       </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="no">:form</span><span class="w">
        </span><span class="p">[</span><span class="n">email-form</span><span class="w"> </span><span class="n">email-address</span><span class="p">]]])))</span></code></pre></figure>

<p>Try it out! As you click in and click out, you should see the prompt message appear and disappear.
Finally, we want a little validation. If the field is required, we want our form to throw out a little message if it’s not filled in. This is a simple addition. Let’s change our input-and-prompt method to take in a required? attribute and display a message saying “Field is required!” when the field is empty.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">input-and-prompt</span><span class="w">
  </span><span class="s">"Creates an input box and a prompt box that appears above the input when the input comes into focus. Also throws in a little required message"</span><span class="w">
  </span><span class="p">[</span><span class="n">label-value</span><span class="w"> </span><span class="n">input-name</span><span class="w"> </span><span class="n">input-type</span><span class="w"> </span><span class="n">input-element-arg</span><span class="w"> </span><span class="n">prompt-element</span><span class="w"> </span><span class="n">required?</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">input-focus</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">false</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w">
       </span><span class="p">[</span><span class="no">:label</span><span class="w"> </span><span class="n">label-value</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="o">@</span><span class="n">input-focus</span><span class="w"> </span><span class="n">prompt-element</span><span class="w"> </span><span class="p">[</span><span class="no">:div</span><span class="p">])</span><span class="w">
       </span><span class="p">[</span><span class="n">input-element</span><span class="w"> </span><span class="n">input-name</span><span class="w"> </span><span class="n">input-name</span><span class="w"> </span><span class="n">input-type</span><span class="w"> </span><span class="n">input-element-arg</span><span class="w"> </span><span class="n">input-focus</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">required?</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">""</span><span class="w"> </span><span class="o">@</span><span class="n">input-element-arg</span><span class="p">))</span><span class="w">
         </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="s">"Field is required!"</span><span class="p">]</span><span class="w">
         </span><span class="p">[</span><span class="no">:div</span><span class="p">])])))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">email-form</span><span class="w">
 </span><span class="p">[</span><span class="n">email-address-atom</span><span class="p">]</span><span class="w">
 </span><span class="p">(</span><span class="nf">input-and-prompt</span><span class="w"> </span><span class="s">"email"</span><span class="w">
                   </span><span class="s">"email"</span><span class="w">
                   </span><span class="s">"email"</span><span class="w">
                   </span><span class="n">email-address-atom</span><span class="w">
                   </span><span class="p">[</span><span class="n">prompt-message</span><span class="w"> </span><span class="s">"What's your email?"</span><span class="p">]</span><span class="w">
                   </span><span class="n">true</span><span class="p">))</span></code></pre></figure>

<h2 id="the-power-of-generics---create-a-name-form-and-a-password-form">The power of generics - create a name form and a password form</h2>

<p>Hopefully this works as expected. Now you must be thinking, why did we define so many generic components instead of directly creating the components themselves? Couldn’t we have tailored input-and-prompt to just worry about email addresses? Well we could have. But because we made it generic, we now a password, and name form for free! Just add in the following:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">name-form</span><span class="w"> </span><span class="p">[</span><span class="n">name-atom</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">input-and-prompt</span><span class="w"> </span><span class="s">"name"</span><span class="w">
                    </span><span class="s">"name"</span><span class="w">
                    </span><span class="s">"text"</span><span class="w">
                    </span><span class="n">name-atom</span><span class="w">
                    </span><span class="p">(</span><span class="nf">prompt-message</span><span class="w"> </span><span class="s">"What's your name?"</span><span class="p">)</span><span class="w">
                    </span><span class="n">true</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">password-form</span><span class="w"> </span><span class="p">[</span><span class="n">password-atom</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">input-and-prompt</span><span class="w"> </span><span class="s">"password"</span><span class="w">
                    </span><span class="s">"password"</span><span class="w">
                    </span><span class="s">"password"</span><span class="w">
                    </span><span class="n">password-atom</span><span class="w">
                    </span><span class="p">(</span><span class="nf">prompt-message</span><span class="w"> </span><span class="s">"What's your password?"</span><span class="p">)</span><span class="w">
                    </span><span class="n">true</span><span class="p">))</span></code></pre></figure>

<p>This to me is a big deal. We can now create UI elements using reusable, testable, utility functions. I don’t think that’s particularly easy in most setups. Let’s add in these additional forms by changing the home-page method to be the following:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
 </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">email-address</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
       </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
       </span><span class="n">password</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
     </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
      </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
      </span><span class="p">[</span><span class="no">:form</span><span class="w">
       </span><span class="p">[</span><span class="n">email-form</span><span class="w"> </span><span class="n">email-address</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="n">name-form</span><span class="w"> </span><span class="nb">name</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="n">password-form</span><span class="w"> </span><span class="n">password</span><span class="p">]]])))</span></code></pre></figure>

<h2 id="bonus---applying-additional-validation-on-the-password">Bonus - Applying Additional validation on the password</h2>

<p>Ok! Onto the last challenge. We are going to validate the password field a little more heavily. We want the password to be at least 8 characters long, have at least 1 special character, and have at least one digit. Let’s start by defining some regexps to check for this.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">check-nil-then-predicate</span><span class="w">
  </span><span class="s">"Check if the value is nil, then apply the predicate"</span><span class="w">
  </span><span class="p">[</span><span class="n">value</span><span class="w"> </span><span class="n">predicate</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
    </span><span class="n">false</span><span class="w">
    </span><span class="p">(</span><span class="nf">predicate</span><span class="w"> </span><span class="n">value</span><span class="p">)))</span><span class="w">


</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">eight-or-more-characters?</span><span class="w">
  </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">check-nil-then-predicate</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="mi">7</span><span class="p">))))</span><span class="w">


</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">has-special-character?</span><span class="w">
  </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">check-nil-then-predicate</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">re-seq</span><span class="w"> </span><span class="o">#</span><span class="s">"\W+"</span><span class="w"> </span><span class="n">arg</span><span class="p">))))))</span><span class="w">


</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">has-number?</span><span class="w">
  </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">check-nil-then-predicate</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="p">(</span><span class="nb">re-seq</span><span class="w"> </span><span class="o">#</span><span class="s">"\d+"</span><span class="w"> </span><span class="n">arg</span><span class="p">)))))</span></code></pre></figure>

<p>Ok great. We now move on to defining the component that will show what requirements we haven’t satisfied yet in our password. It’s going to be a list where requirements disappear as we meet them. The function will take in a data structure like the one pasted below it.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">password-requirements</span><span class="w">
  </span><span class="s">"A list to describe which password requirements have been met so far"</span><span class="w">
  </span><span class="p">[</span><span class="n">password</span><span class="w"> </span><span class="n">requirements</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="w">
   </span><span class="p">[</span><span class="no">:ul</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">requirements</span><span class="w">
             </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">req</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">((</span><span class="no">:check-fn</span><span class="w"> </span><span class="n">req</span><span class="p">)</span><span class="w"> </span><span class="o">@</span><span class="n">password</span><span class="p">))))</span><span class="w">
             </span><span class="p">(</span><span class="nb">doall</span><span class="p">)</span><span class="w">
             </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">req</span><span class="p">]</span><span class="w"> </span><span class="o">^</span><span class="p">{</span><span class="no">:key</span><span class="w"> </span><span class="n">req</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="no">:li</span><span class="w"> </span><span class="p">(</span><span class="no">:message</span><span class="w"> </span><span class="n">req</span><span class="p">)])))]])</span></code></pre></figure>

<p>Let’s break down the function above. It’s taking in a password (atom) and a set of requirements. You can see what the requirements data structure looks like below.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[{</span><span class="no">:message</span><span class="w"> </span><span class="s">"8 or more characters"</span><span class="w"> </span><span class="no">:check-fn</span><span class="w"> </span><span class="n">eight-or-more-characters?</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"At least one special character"</span><span class="w"> </span><span class="no">:check-fn</span><span class="w"> </span><span class="n">has-special-character?</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"At least one number"</span><span class="w"> </span><span class="no">:check-fn</span><span class="w"> </span><span class="n">has-number?</span><span class="p">}]</span></code></pre></figure>

<p>password-requirements then returns a div with a ul list inside it.</p>

<p>For each requirement, we filter out the requirements that aren’t passed, and then map those requirements to create :li elements whose contents are just the messages of the requirements. This is cool. Again, this shows how we are doing things most templating languages can’t really do.</p>

<p>Let’s now change our password-form to use these requirements.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">password-form</span><span class="w">
  </span><span class="p">[</span><span class="n">password</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">password-type-atom</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="s">"password"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w">
       </span><span class="p">[(</span><span class="nf">input-and-prompt</span><span class="w"> </span><span class="s">"password"</span><span class="w">
                          </span><span class="s">"password"</span><span class="w">
                          </span><span class="o">@</span><span class="n">password-type-atom</span><span class="w">
                          </span><span class="n">password</span><span class="w">
                          </span><span class="p">(</span><span class="nf">prompt-message</span><span class="w"> </span><span class="s">"What's your password"</span><span class="p">)</span><span class="w">
                          </span><span class="n">true</span><span class="p">)]</span><span class="w">
       </span><span class="p">[</span><span class="n">password-requirements</span><span class="w"> </span><span class="n">password</span><span class="w"> </span><span class="p">[{</span><span class="no">:message</span><span class="w"> </span><span class="s">"8 or more characters"</span><span class="w"> </span><span class="no">:check-fn</span><span class="w"> </span><span class="n">eight-or-more-characters?</span><span class="p">}</span><span class="w">
                                        </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"At least one special character"</span><span class="w"> </span><span class="no">:check-fn</span><span class="w"> </span><span class="n">has-special-character?</span><span class="p">}</span><span class="w">
                                        </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"At least one number"</span><span class="w"> </span><span class="no">:check-fn</span><span class="w"> </span><span class="n">has-number?</span><span class="p">}]]])))</span></code></pre></figure>

<p>Finally, notice that password-form, input-form etc. aren’t in a form-group class. Let’s fix that. We create the following function:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-as-element-in-form</span><span class="w">
  </span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class=</span><span class="s">"row form-group"</span><span class="p">}</span><span class="w">
   </span><span class="n">element</span><span class="p">])</span></code></pre></figure>

<p>And then use it to wrap all our forms in form-group elements.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">home-page</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">email-address</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
        </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
        </span><span class="n">password</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"signup-wrapper"</span><span class="p">}</span><span class="w">
       </span><span class="p">[</span><span class="no">:h2</span><span class="w"> </span><span class="s">"Welcome to TestChimp"</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="no">:form</span><span class="w">
        </span><span class="p">(</span><span class="nf">wrap-as-element-in-form</span><span class="w"> </span><span class="p">[</span><span class="n">email-form</span><span class="w"> </span><span class="n">email-address</span><span class="p">])</span><span class="w">
        </span><span class="p">(</span><span class="nf">wrap-as-element-in-form</span><span class="w"> </span><span class="p">[</span><span class="n">name-form</span><span class="w"> </span><span class="nb">name</span><span class="p">])</span><span class="w">
        </span><span class="p">(</span><span class="nf">wrap-as-element-in-form</span><span class="w"> </span><span class="p">[</span><span class="n">password-form</span><span class="w"> </span><span class="n">password</span><span class="p">])]])))</span></code></pre></figure>

<p>That’s it for now! Your final code should match the file <a href="https://github.com/dhruvp/mailchimp-form-cljs/blob/master/src/cljs/mailchimp_form/core.cljs">here</a>.</p>

<h2 id="so-what-have-we-learned">So what have we learned?</h2>

<p>We went through something really cool in this post (I think at least!). We applied the Clojure principle of using simple, composable functions as a way of building UIs! And why should we not? Can’t frontend software development also use the same principles of modularity, simplicity, and composition? Indeed, I think with Clojurescript and Reagent, it can.</p>

<p>More specifically, here are my main takeaways:</p>

<ol>
  <li>
    <p>It’s really nice to be able to treat UI elements as first class data structures that you can compose and apply logic on. I think it does lead to more modular pieces.</p>
  </li>
  <li>
    <p>It’s also very nice that you can use clojure as your templating language! No need for feeling hamstrung by a lack of functionality there and we don’t have to learn any new languages.</p>
  </li>
  <li>
    <p>Reagent is also just a really simple to use library. Atoms abstract away any worrying about rerendering elements and the syntax of using reagent is dead simple.</p>
  </li>
  <li>
    <p>It is hard for me to debug clojurescript code. I still don’t know how to do this efficiently. Many times I would see errors and have no idea why they were ocurring. In JavaScript, I would just breakpoint my code to catch the error. Here I couldn’t do that. Also, at times I would have to run lein clean and then rerun a cljscript autobuild and this took like 30 seconds each time. You can imagine that this is not fun.</p>
  </li>
</ol>

  </article>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    
      <a class="pagination-item newer" href="/page3">Newer</a>
    
  
</div>

      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2018-12-31T16:56:06-08:00">2018</time>. All rights reserved.
        </small>
      </footer>
    </div>

  </body>
</html>
